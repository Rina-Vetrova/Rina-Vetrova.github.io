<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif; 
      overflow: hidden;
      background: #f5f5f5;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: white;
      cursor: crosshair;
    }
    
    #toolsPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 250px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    #toolsPanel.hidden {
      transform: translateX(270px);
      opacity: 0;
    }
    
    #toolsHeader {
      padding: 15px;
      background: #333;
      color: white;
      border-radius: 10px 10px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #toolsContent {
      padding: 15px;
      max-height: 70vh;
      overflow-y: auto;
    }
    
    #toggleBtn {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: #333;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: all 0.3s ease;
    }
    
    #toggleBtn:hover {
      background: #555;
      transform: scale(1.1);
    }
    
    #toggleBtn.panelOpen {
      right: 290px;
    }
    
    button {
      width: 100%;
      margin: 5px 0;
      padding: 10px;
      border: none;
      border-radius: 5px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #0056b3;
    }
    
    button.active {
      background: #28a745;
    }
    
    textarea {
      width: 100%;
      height: 100px;
      margin: 5px 0;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }
    
    label {
      display: block;
      margin: 10px 0 5px 0;
      font-weight: bold;
      font-size: 14px;
    }
    
    hr {
      margin: 15px 0;
      border: none;
      border-top: 1px solid #eee;
    }
    
    #log {
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 11px;
      white-space: pre;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e9ecef;
    }
    
    .control-point {
      cursor: grab;
      transition: all 0.2s ease;
    }
    
    .control-point:hover {
      r: 7;
      fill: #dc3545;
    }
    
    .control-point:active {
      cursor: grabbing;
    }
    
    .helper-line {
      stroke: #999;
      stroke-width: 1;
      stroke-dasharray: 3,3;
      opacity: 0.6;
    }
    
    #modeSelector {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    #modeSelector button {
      flex: 1;
      font-size: 12px;
      padding: 8px 4px;
    }
  </style>
</head>
<body>
    <svg id="canvas" width="600" height="400"></svg>
    <button id="toggleBtn">‚ò∞</button>

    <div id="toolsPanel" class="hidden" style="position: absolute; top: 10px; left: 10px;">
        <div id="toolsHeader" style="cursor: move;">
            <span>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</span>
            <span style="cursor: pointer;" onclick="togglePanel()">√ó</span>
        </div>
        <div id="toolsContent">
            <div id="modeSelector">
                <button class="mode-button" data-mode="M">Move (M)</button>
                <button class="mode-button" data-mode="L">Line (L)</button>
                <button class="mode-button" data-mode="Q">Quadratic Bezier (Q)</button>
                <button class="mode-button" data-mode="C">Cubic Bezier (C)</button>
            </div>
            <button id="insertImage">üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ–Ω</button>
            <button id="toggleBgControl">‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–Ω–æ–º</button>
            <button id="clearPath">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
            <button id="undo">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
            <button id="exportSvg">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å SVG</button>
            <hr>
            <label>SVG –∫–æ–¥:</label>
            <div id="log" style="white-space: pre; font-family: monospace;"></div>
        </div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById('canvas');
            const toolsPanel = document.getElementById('toolsPanel');
            const toggleBtn = document.getElementById('toggleBtn');
            const modeButtons = document.querySelectorAll('.mode-button');
            const insertImageButton = document.getElementById('insertImage');
            const toggleBgControlButton = document.getElementById('toggleBgControl');
            const clearPathButton = document.getElementById('clearPath');
            const undoButton = document.getElementById('undo');
            const exportSvgButton = document.getElementById('exportSvg');
            const logEl = document.getElementById('log');

            let currentMode = 'M';
            let segments = [];
            let isDraggingPanel = false;
            let panelOffsetX, panelOffsetY;
            let isControllingBackground = false;
            let bgScale = 1;
            let bgTranslate = { x: 0, y: 0 };
            let isDraggingBg = false, startXBg, startYBg;

            const svgNS = "http://www.w3.org/2000/svg";

            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('style', 'position:absolute; top:0; left:0;');
            canvas.appendChild(svg);

            // Background group
            const bgGroup = document.createElementNS(svgNS, "g");
            bgGroup.setAttribute('id', 'bgGroup');
            svg.appendChild(bgGroup);

            const bgImage = document.createElementNS(svgNS, "image");
            bgImage.setAttribute('id', 'bgImage');
            bgGroup.appendChild(bgImage);

            const helperLinesGroup = document.createElementNS(svgNS, "g");
            helperLinesGroup.setAttribute('id', 'helper-lines');
            svg.appendChild(helperLinesGroup);

            const controlPointsGroup = document.createElementNS(svgNS, "g");
            controlPointsGroup.setAttribute('id', 'control-points');
            svg.appendChild(controlPointsGroup);

            const pathEl = document.createElementNS(svgNS, "path");
            pathEl.setAttribute('id', 'path');
            svg.appendChild(pathEl);

            const commandHandlers = {
                'M': (s) => s.pts.forEach(pt => createControlPoint(pt)),
                'L': (s) => s.pts.forEach(pt => createControlPoint(pt)),
                'Q': (s) => {
                    createControlPoint(s.pts[0]);
                    createControlPoint(s.pts[1], 'control');
                    createControlPoint(s.pts[2]);
                    createHelperLine(s.pts[0], s.pts[1]);
                    createHelperLine(s.pts[1], s.pts[2]);
                },
                'C': (s) => {
                    createControlPoint(s.pts[0]);
                    createControlPoint(s.pts[1], 'control');
                    createControlPoint(s.pts[2], 'control');
                    createControlPoint(s.pts[3]);
                    createHelperLine(s.pts[0], s.pts[1]);
                    createHelperLine(s.pts[2], s.pts[3]);
                }
            };

            function redraw() {
                let d = '';
                clearControlPoints();

                segments.forEach(s => {
                    if (commandHandlers[s.cmd]) {
                        commandHandlers[s.cmd](s);
                        d += s.cmd + ' ' + s.pts.map(pt => `${pt.x} ${pt.y}`).join(' ') + ' ';
                    }
                });

                pathEl.setAttribute('d', d.trim());
                logEl.textContent = segments.map(s => `${s.cmd} ${s.pts.map(pt => `${pt.x.toFixed(1)} ${pt.y.toFixed(1)}`).join(' ')}`).join('\n');
            }

            function addPoint(x, y) {
                const last = segments.length ? segments[segments.length - 1].pts.slice(-1)[0] : null;
                const createPts = {
                    'M': () => [{ x, y }],
                    'L': () => last ? [last, { x, y }] : null,
                    'Q': () => last ? [
                        last,
                        { x: (last.x + x) / 2, y: (last.y + y) / 2 - 50 },
                        { x, y }
                    ] : null,
                    'C': () => last ? [
                        last,
                        { x: last.x + (x - last.x) * 0.3, y: last.y + (y - last.y) * 0.3 - 30 },
                        { x: last.x + (x - last.x) * 0.7, y: last.y + (y - last.y) * 0.7 + 30 },
                        { x, y }
                    ] : null
                };

                const pts = createPts[currentMode]?.();
                if (!pts) return;

                segments.push({ cmd: currentMode, pts });
                redraw();
            }

            function createControlPoint(pt, type = '') {
                const circle = document.createElementNS(svgNS, "circle");
                circle.setAttribute('cx', pt.x);
                circle.setAttribute('cy', pt.y);
                circle.setAttribute('r', 5);
                circle.setAttribute('class', `control-point ${type}`);
                controlPointsGroup.appendChild(circle);

                let isDragging = false;
                let offsetX, offsetY;

                circle.addEventListener('mousedown', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    isDragging = true;
                    circle.classList.add('dragging');
                    offsetX = e.clientX - pt.x;
                    offsetY = e.clientY - pt.y;

                    const move = e => {
                        if (!isDragging) return;
                        pt.x = e.clientX - offsetX;
                        pt.y = e.clientY - offsetY;
                        circle.setAttribute('cx', pt.x);
                        circle.setAttribute('cy', pt.y);
                        redraw();
                    };

                    const up = () => {
                        isDragging = false;
                        circle.classList.remove('dragging');
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', up);
                    };

                    document.addEventListener('mousemove', move);
                    document.addEventListener('mouseup', up);
                });
            }

            function createHelperLine(pt1, pt2) {
                const line = document.createElementNS(svgNS, "line");
                line.setAttribute('x1', pt1.x);
                line.setAttribute('y1', pt1.y);
                line.setAttribute('x2', pt2.x);
                line.setAttribute('y2', pt2.y);
                line.setAttribute('class', 'helper-line');
                helperLinesGroup.appendChild(line);
            }

            function clearControlPoints() {
                controlPointsGroup.innerHTML = '';
                helperLinesGroup.innerHTML = '';
            }

            // === –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ===
            toolsPanel.addEventListener('mousedown', (e) => {
                const header = toolsPanel.querySelector('#toolsHeader');
                if (header.contains(e.target)) {
                    isDraggingPanel = true;
                    panelOffsetX = e.clientX - toolsPanel.offsetLeft;
                    panelOffsetY = e.clientY - toolsPanel.offsetTop;
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingPanel = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingPanel) return;
                toolsPanel.style.left = (e.clientX - panelOffsetX) + 'px';
                toolsPanel.style.top = (e.clientY - panelOffsetY) + 'px';
            });

            // –ö–Ω–æ–ø–∫–∏
            window.togglePanel = function () {
                const isHidden = toolsPanel.classList.toggle('hidden');
                toggleBtn.textContent = isHidden ? '‚ò∞' : '√ó';
            };
            toggleBtn.onclick = togglePanel;

            undoButton.onclick = () => {
                segments.pop();
                redraw();
            };

            clearPathButton.onclick = () => {
                segments = [];
                redraw();
            };

            exportSvgButton.onclick = () => {
                const content = `<svg xmlns="${svgNS}" width="${canvas.clientWidth}" height="${canvas.clientHeight}">${svg.innerHTML}</svg>`;
                const blob = new Blob([content], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawing.svg';
                a.click();
            };

            insertImageButton.onclick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = e => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = evt => {
                        bgImage.setAttribute('href', evt.target.result);
                        updateBgTransform();
                    };
                    reader.readAsDataURL(file);
                };
                input.click();
            };

            toggleBgControlButton.onclick = () => {
                isControllingBackground = !isControllingBackground;
                toggleBgControlButton.classList.toggle('active', isControllingBackground);
                canvas.style.cursor = isControllingBackground ? 'grab' : 'default';
            };

            function updateBgTransform() {
                bgGroup.setAttribute('transform', `translate(${bgTranslate.x},${bgTranslate.y}) scale(${bgScale})`);
            }

            canvas.addEventListener('wheel', (e) => {
                if (!isControllingBackground) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                bgScale = Math.max(0.1, Math.min(5, bgScale + delta));
                updateBgTransform();
            });

            canvas.addEventListener('mousedown', (e) => {
                if (!isControllingBackground) return;
                isDraggingBg = true;
                startXBg = e.clientX - bgTranslate.x;
                startYBg = e.clientY - bgTranslate.y;
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mouseup', () => {
                isDraggingBg = false;
                if (isControllingBackground) canvas.style.cursor = 'grab';
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isControllingBackground && isDraggingBg) {
                    bgTranslate.x = e.clientX - startXBg;
                    bgTranslate.y = e.clientY - startYBg;
                    updateBgTransform();
                }
            });

            // –¢–æ—á–∫–∏ –ø–æ –∫–ª–∏–∫—É
            canvas.addEventListener('click', e => {
                if (isControllingBackground) return;
                const rect = canvas.getBoundingClientRect();
                addPoint(e.clientX - rect.left, e.clientY - rect.top);
            });

            // –†–µ–∂–∏–º
            modeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    currentMode = button.dataset.mode;
                    modeButtons.forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                });
            });

            // Init
            document.querySelector('[data-mode="M"]').classList.add('active');
            addPoint(50, 50);
        })();
    </script>

    <style>
        .hidden { display: none; }
        .control-point { fill: red; cursor: pointer; }
        .control-point.control { fill: orange; }
        .helper-line { stroke: gray; stroke-dasharray: 4; }
        .mode-button.active { background: #ddd; }
        #canvas { border: 1px solid #ccc; }
    </style>
</body>

</html>
