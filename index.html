<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif; 
      overflow: hidden;
      background: #f5f5f5;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: white;
      cursor: crosshair;
    }
    
    #toolsPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 250px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    #toolsPanel.hidden {
      transform: translateX(270px);
      opacity: 0;
    }
    
    #toolsHeader {
      padding: 15px;
      background: #333;
      color: white;
      border-radius: 10px 10px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #toolsContent {
      padding: 15px;
      max-height: 70vh;
      overflow-y: auto;
    }
    
    #toggleBtn {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: #333;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: all 0.3s ease;
    }
    
    #toggleBtn:hover {
      background: #555;
      transform: scale(1.1);
    }
    
    #toggleBtn.panelOpen {
      right: 290px;
    }
    
    button {
      width: 100%;
      margin: 5px 0;
      padding: 10px;
      border: none;
      border-radius: 5px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #0056b3;
    }
    
    button.active {
      background: #28a745;
    }
    
    textarea {
      width: 100%;
      height: 100px;
      margin: 5px 0;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }
    
    label {
      display: block;
      margin: 10px 0 5px 0;
      font-weight: bold;
      font-size: 14px;
    }
    
    hr {
      margin: 15px 0;
      border: none;
      border-top: 1px solid #eee;
    }
    
    #log {
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 11px;
      white-space: pre;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e9ecef;
    }
    
    .control-point {
      cursor: grab;
      transition: all 0.2s ease;
    }
    
    .control-point:hover {
      r: 7;
      fill: #dc3545;
    }
    
    .control-point:active {
      cursor: grabbing;
    }
    
    .helper-line {
      stroke: #999;
      stroke-width: 1;
      stroke-dasharray: 3,3;
      opacity: 0.6;
    }
    
    #modeSelector {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    #modeSelector button {
      flex: 1;
      font-size: 12px;
      padding: 8px 4px;
    }
  </style>
</head>
<body>

  <svg id="canvas" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#f0f0f0" stroke-width="1"/>
      </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#grid)" opacity="0.5"/>
    <image id="bgImage" x="0" y="0" width="0" height="0" href="" preserveAspectRatio="xMidYMid slice"/>
    <g id="helperLines"></g>
    <path id="path" fill="none" stroke="#333" stroke-width="3"/>
    <g id="controlPoints"></g>
  </svg>

  <button id="toggleBtn">‚ò∞</button>

  <div id="toolsPanel" class="hidden">
    <div id="toolsHeader">
      <span>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</span>
      <span style="cursor: pointer;" onclick="togglePanel()">√ó</span>
    </div>
    <div id="toolsContent">
      <div id="modeSelector">
        <button id="addMove" class="active">M</button>
        <button id="addH">H</button>
        <button id="addV">V</button>
        <button id="addLine">L</button>
        <button id="addQuad">Q</button>
        <button id="addCubic">C</button>
      </div>
      
      <button id="insertImage">üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ–Ω</button>
      <button id="clearPath">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
      
      <hr>
      
      <label>–í—Å—Ç–∞–≤–∏—Ç—å —Å–µ–≥–º–µ–Ω—Ç—ã:</label>
      <textarea id="inputSeg" placeholder="M 100 100
H 200
V 150
L 250 200
Q 300 150, 350 200
C 360 180, 400 100, 450 150"></textarea>
      <button id="loadSeg">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ —Ç–µ–∫—Å—Ç–∞</button>
      
      <hr>
      
      <label>SVG –∫–æ–¥:</label>
      <div id="log"></div>
    </div>
  </div>

<script>
(() => {
  const svg = document.getElementById('canvas');
  const pathEl = document.getElementById('path');
  const logEl = document.getElementById('log');
  const bgImage = document.getElementById('bgImage');
  const controlPointsGroup = document.getElementById('controlPoints');
  const helperLinesGroup = document.getElementById('helperLines');
  const toolsPanel = document.getElementById('toolsPanel');
  const toggleBtn = document.getElementById('toggleBtn');

  let segments = [];
  let currentMode = 'M';
  let isDrawing = false;

  // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ø–∞–Ω–µ–ª–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
  window.togglePanel = function() {
    const isHidden = toolsPanel.classList.contains('hidden');
    if (isHidden) {
      toolsPanel.classList.remove('hidden');
      toggleBtn.classList.add('panelOpen');
      toggleBtn.textContent = '√ó';
    } else {
      toolsPanel.classList.add('hidden');
      toggleBtn.classList.remove('panelOpen');
      toggleBtn.textContent = '‚ò∞';
    }
  };

  toggleBtn.onclick = togglePanel;

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ canvas
  function updateCanvasSize() {
    svg.setAttribute('width', window.innerWidth);
    svg.setAttribute('height', window.innerHeight);
  }
  
  updateCanvasSize();
  window.addEventListener('resize', updateCanvasSize);

  function createControlPoint(pt, type = 'main') {
    const c = document.createElementNS(svg.namespaceURI, 'circle');
    c.setAttribute('cx', pt.x);
    c.setAttribute('cy', pt.y);
    c.setAttribute('r', 5);
    c.setAttribute('fill', type === 'control' ? '#17a2b8' : '#e74c3c');
    c.setAttribute('class', 'control-point');
    controlPointsGroup.appendChild(c);
    
    let isDragging = false;
    let startX, startY;
    
    c.addEventListener('mousedown', e => {
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      startX = e.clientX - pt.x;
      startY = e.clientY - pt.y;
      
      const onMouseMove = e => {
        if (!isDragging) return;
        pt.x = e.clientX - startX;
        pt.y = e.clientY - startY;
        c.setAttribute('cx', pt.x);
        c.setAttribute('cy', pt.y);
        redraw();
      };
      
      const onMouseUp = () => {
        isDragging = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
    
    return c;
  }

  function createHelperLine(pt1, pt2) {
    const line = document.createElementNS(svg.namespaceURI, 'line');
    line.setAttribute('x1', pt1.x);
    line.setAttribute('y1', pt1.y);
    line.setAttribute('x2', pt2.x);
    line.setAttribute('y2', pt2.y);
    line.setAttribute('class', 'helper-line');
    helperLinesGroup.appendChild(line);
    return line;
  }

  function clearControlPoints() {
    controlPointsGroup.innerHTML = '';
    helperLinesGroup.innerHTML = '';
  }

  function redraw() {
    let d = '';
    clearControlPoints();
    
    segments.forEach((s, i) => {
      const pts = s.pts;
      switch(s.cmd) {
        case 'M':
          pts.forEach(pt => {
            d += `M${pt.x} ${pt.y} `;
            createControlPoint(pt);
          });
          break;
        case 'H':
          d += `H${pts[1].x} `;
          createControlPoint(pts[0]);
          createControlPoint(pts[1]);
          break;
        case 'V':
          d += `V${pts[1].y} `;
          createControlPoint(pts[0]);
          createControlPoint(pts[1]);
          break;
        case 'L': {
          const dx = pts[1].x - pts[0].x, dy = pts[1].y - pts[0].y;
          if (dy === 0) d += `H${pts[1].x} `;
          else if (dx === 0) d += `V${pts[1].y} `;
          else d += `L${pts[1].x} ${pts[1].y} `;
          
          createControlPoint(pts[0]);
          createControlPoint(pts[1]);
        } break;
        case 'Q':
          d += `Q${pts[1].x} ${pts[1].y}, ${pts[2].x} ${pts[2].y} `;
          createControlPoint(pts[0]);
          createControlPoint(pts[1], 'control');
          createControlPoint(pts[2]);
          createHelperLine(pts[0], pts[1]);
          createHelperLine(pts[1], pts[2]);
          break;
        case 'C':
          d += `C${pts[1].x} ${pts[1].y}, ${pts[2].x} ${pts[2].y}, ${pts[3].x} ${pts[3].y} `;
          createControlPoint(pts[0]);
          createControlPoint(pts[1], 'control');
          createControlPoint(pts[2], 'control');
          createControlPoint(pts[3]);
          createHelperLine(pts[0], pts[1]);
          createHelperLine(pts[2], pts[3]);
          break;
      }
    });
    
    pathEl.setAttribute('d', d.trim());

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∞
    let txt = '';
    segments.forEach(s => {
      switch(s.cmd) {
        case 'M':
          s.pts.forEach(pt => txt += `M ${pt.x.toFixed(1)} ${pt.y.toFixed(1)}\n`);
          break;
        case 'H':
          txt += `H ${s.pts[1].x.toFixed(1)}\n`; break;
        case 'V':
          txt += `V ${s.pts[1].y.toFixed(1)}\n`; break;
        case 'L':
          txt += `L ${s.pts[1].x.toFixed(1)} ${s.pts[1].y.toFixed(1)}\n`; break;
        case 'Q':
          txt += `Q ${s.pts[1].x.toFixed(1)} ${s.pts[1].y.toFixed(1)}, ${s.pts[2].x.toFixed(1)} ${s.pts[2].y.toFixed(1)}\n`; break;
        case 'C':
          txt += `C ${s.pts[1].x.toFixed(1)} ${s.pts[1].y.toFixed(1)}, ${s.pts[2].x.toFixed(1)} ${s.pts[2].y.toFixed(1)}, ${s.pts[3].x.toFixed(1)} ${s.pts[3].y.toFixed(1)}\n`; break;
      }
    });
    logEl.textContent = txt;
  }

  function addPoint(x, y) {
    const last = segments.length ? segments[segments.length-1].pts.slice(-1)[0] : null;
    let pts = [];
    
    switch(currentMode) {
      case 'M':
        pts = [{x, y}];
        break;
      case 'H':
        if (!last) return;
        pts = [{x: last.x, y: last.y}, {x, y: last.y}];
        break;
      case 'V':
        if (!last) return;
        pts = [{x: last.x, y: last.y}, {x: last.x, y}];
        break;
      case 'L':
        if (!last) return;
        pts = [{x: last.x, y: last.y}, {x, y}];
        break;
      case 'Q':
        if (!last) return;
        pts = [
          {x: last.x, y: last.y},
          {x: (last.x + x) / 2, y: (last.y + y) / 2 - 50},
          {x, y}
        ];
        break;
      case 'C':
        if (!last) return;
        const dx = x - last.x;
        const dy = y - last.y;
        pts = [
          {x: last.x, y: last.y},
          {x: last.x + dx * 0.3, y: last.y + dy * 0.3 - 30},
          {x: last.x + dx * 0.7, y: last.y + dy * 0.7 + 30},
          {x, y}
        ];
        break;
    }
    
    if (pts.length) {
      segments.push({cmd: currentMode, pts});
      redraw();
    }
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ canvas
  svg.addEventListener('click', e => {
    if (e.target === svg || e.target.tagName === 'rect') {
      const rect = svg.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      addPoint(x, y);
    }
  });

  // –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞
  function setMode(mode) {
    currentMode = mode;
    document.querySelectorAll('#modeSelector button').forEach(btn => {
      btn.classList.remove('active');
    });
    document.getElementById('add' + mode).classList.add('active');
  }

  document.getElementById('addMove').onclick = () => setMode('M');
  document.getElementById('addH').onclick = () => setMode('H');
  document.getElementById('addV').onclick = () => setMode('V');
  document.getElementById('addLine').onclick = () => setMode('L');
  document.getElementById('addQuad').onclick = () => setMode('Q');
  document.getElementById('addCubic').onclick = () => setMode('C');

  // –û—á–∏—Å—Ç–∫–∞ –ø—É—Ç–∏
  document.getElementById('clearPath').onclick = () => {
    segments = [];
    redraw();
  };

  // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞
  document.getElementById('loadSeg').onclick = () => {
    segments = [];
    const lines = document.getElementById('inputSeg').value.trim().split(/[\r\n]+/);
    let currentPos = {x: 0, y: 0};
    
    lines.forEach(ln => {
      const m = ln.trim().match(/^([MHVLQC])\s*(.*)$/i);
      if (!m) return;
      const cmd = m[1].toUpperCase();
      const nums = m[2].replace(/,/g, ' ').trim().split(/\s+/).map(Number);
      let pts = [];
      
      switch(cmd) {
        case 'M':
          pts = [{x: nums[0], y: nums[1]}];
          currentPos = {x: nums[0], y: nums[1]};
          break;
        case 'H':
          pts = [{...currentPos}, {x: nums[0], y: currentPos.y}];
          currentPos.x = nums[0];
          break;
        case 'V':
          pts = [{...currentPos}, {x: currentPos.x, y: nums[0]}];
          currentPos.y = nums[0];
          break;
        case 'L':
          pts = [{...currentPos}, {x: nums[0], y: nums[1]}];
          currentPos = {x: nums[0], y: nums[1]};
          break;
        case 'Q':
          pts = [{...currentPos}, {x: nums[0], y: nums[1]}, {x: nums[2], y: nums[3]}];
          currentPos = {x: nums[2], y: nums[3]};
          break;
        case 'C':
          pts = [{...currentPos}, {x: nums[0], y: nums[1]}, {x: nums[2], y: nums[3]}, {x: nums[4], y: nums[5]}];
          currentPos = {x: nums[4], y: nums[5]};
          break;
      }
      
      if (pts.length) {
        segments.push({cmd, pts});
      }
    });
    redraw();
  };

  // –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  document.getElementById('insertImage').onclick = () => {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = 'image/*';
    inp.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = ev => {
        bgImage.setAttribute('href', ev.target.result);
        const img = new Image();
        img.onload = () => {
          bgImage.setAttribute('width', img.width);
          bgImage.setAttribute('height', img.height);
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    };
    inp.click();
  };

  // –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'TEXTAREA') return;
    
    switch(e.key.toLowerCase()) {
      case 'm': setMode('M'); break;
      case 'h': setMode('H'); break;
      case 'v': setMode('V'); break;
      case 'l': setMode('L'); break;
      case 'q': setMode('Q'); break;
      case 'c': setMode('C'); break;
      case ' ': e.preventDefault(); togglePanel(); break;
      case 'escape': 
        toolsPanel.classList.add('hidden');
        toggleBtn.classList.remove('panelOpen');
        toggleBtn.textContent = '‚ò∞';
        break;
    }
  });

  redraw();
})();
</script>

</body>
</html>
