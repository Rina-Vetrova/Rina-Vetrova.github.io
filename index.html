<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>SVG Path Editor</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; overflow: hidden; background: #f5f5f5; }
    #canvas {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: white; cursor: crosshair;
      border: 1px solid #ccc;
    }
    #toolsPanel {
      position: fixed; top: 20px; right: 20px; width: 250px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
      z-index: 1000;
    }
    #toolsPanel.hidden { transform: translateX(270px); opacity: 0; }
    #toolsHeader {
      padding: 15px; background: #333; color: white;
      border-radius: 10px 10px 0 0;
      display: flex; justify-content: space-between;
      align-items: center; cursor: move;
    }
    #toolsContent {
      padding: 15px;
      max-height: 70vh; overflow-y: auto;
    }
    #toggleBtn {
      position: fixed; top: 20px; right: 20px;
      width: 50px; height: 50px;
      background: #333; color: white;
      border: none; border-radius: 50%;
      font-size: 20px; cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1100;
      transition: all 0.3s ease;
    }
    #toggleBtn:hover { background: #555; transform: scale(1.1); }
    #toggleBtn.panelOpen { right: 290px; }

    button {
      width: 100%; margin: 5px 0; padding: 10px;
      border: none; border-radius: 5px;
      background: #007bff; color: white;
      cursor: pointer; font-size: 14px;
      transition: background 0.2s;
    }
    button:hover { background: #0056b3; }
    button.active { background: #28a745; }

    textarea {
      width: 100%; height: 100px;
      margin: 5px 0; padding: 8px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: monospace; font-size: 12px;
      resize: vertical;
    }

    label {
      display: block; margin: 10px 0 5px 0;
      font-weight: bold; font-size: 14px;
    }

    hr {
      margin: 15px 0; border: none;
      border-top: 1px solid #eee;
    }

    #log {
      background: #f8f9fa;
      padding: 10px; border-radius: 5px;
      font-family: monospace; font-size: 11px;
      white-space: pre;
      max-height: 200px; overflow-y: auto;
      border: 1px solid #e9ecef;
    }

    .control-point {
      fill: red; cursor: grab;
      transition: all 0.2s ease;
    }

    .control-point:hover { r: 7; fill: #dc3545; }
    .control-point:active { cursor: grabbing; }
    .control-point.control { fill: orange; }

    .dragging { opacity: 0.7; }
    .helper-line {
      stroke: #999; stroke-width: 1;
      stroke-dasharray: 4; opacity: 0.6;
    }

    #modeSelector {
      display: flex; gap: 5px; margin-bottom: 10px;
    }

    #modeSelector button {
      flex: 1; font-size: 12px; padding: 8px 4px;
    }

    .mode-button.active { background: #ddd; }
  </style>
</head>
<body>
  <svg id="canvas"></svg>

  <button id="toggleBtn">‚ò∞</button>

  <div id="toolsPanel" class="hidden">
    <div id="toolsHeader">
      <span>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</span>
      <span style="cursor: pointer;" onclick="togglePanel()">√ó</span>
    </div>
    <div id="toolsContent">
      <div id="modeSelector">
        <button class="mode-button" data-mode="M">Move (M)</button>
        <button class="mode-button" data-mode="L">Line (L)</button>
        <button class="mode-button" data-mode="Q">Quadratic Bezier (Q)</button>
        <button class="mode-button" data-mode="C">Cubic Bezier (C)</button>
      </div>
      <button id="insertImage">üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ–Ω</button>
      <button id="toggleBgControl">‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–Ω–æ–º</button>
<button id="resetView">üîÑ –°–±—Ä–æ—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏</button>

      <button id="clearPath">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
      <button id="undo">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
      <button id="exportSvg">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å SVG</button>
      <hr>
      <label>SVG –∫–æ–¥:</label>
      <div id="log"></div>
    </div>
  </div>

  <script>
(() => {
  const canvas = document.getElementById('canvas');
  const toolsPanel = document.getElementById('toolsPanel');
  const toggleBtn = document.getElementById('toggleBtn');
  const modeButtons = document.querySelectorAll('.mode-button');
  const insertImageButton = document.getElementById('insertImage');
  const toggleBgControlButton = document.getElementById('toggleBgControl');
  const clearPathButton = document.getElementById('clearPath');
  const undoButton = document.getElementById('undo');
  const exportSvgButton = document.getElementById('exportSvg');
  const logEl = document.getElementById('log');

  let currentMode = 'M';
  let segments = [];
  let isDraggingPanel = false;
  let panelOffsetX, panelOffsetY;
  let isControllingBackground = false;

  // –ü–∞–Ω–æ—Ä–∞–º–∞ –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã (—Ñ–æ–Ω + –ø—É—Ç—å)
  let sceneScale = 1;
  let sceneTranslate = { x: 0, y: 0 };
  let isPanning = false;
  let startPan = { x: 0, y: 0 };

  const svgNS = "http://www.w3.org/2000/svg";
  const svg = canvas;
const resetViewButton = document.getElementById('resetView');

resetViewButton.onclick = () => {
  sceneScale = 1;
  sceneTranslate = { x: 0, y: 0 };
  updateSceneTransform();
};
  // –ì—Ä—É–ø–ø–∞ –¥–ª—è –≤—Å–µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Å—Ü–µ–Ω—ã
  const sceneGroup = document.createElementNS(svgNS, "g");
  sceneGroup.setAttribute('id', 'sceneGroup');
  svg.appendChild(sceneGroup);

  const bgGroup = document.createElementNS(svgNS, "g");
  bgGroup.setAttribute('id', 'bgGroup');
  sceneGroup.appendChild(bgGroup);

  const bgImage = document.createElementNS(svgNS, "image");
  bgImage.setAttribute('id', 'bgImage');
  bgGroup.appendChild(bgImage);

  const helperLinesGroup = document.createElementNS(svgNS, "g");
  helperLinesGroup.setAttribute('id', 'helper-lines');
  sceneGroup.appendChild(helperLinesGroup);

  const controlPointsGroup = document.createElementNS(svgNS, "g");
  controlPointsGroup.setAttribute('id', 'control-points');
  sceneGroup.appendChild(controlPointsGroup);

  const pathEl = document.createElementNS(svgNS, "path");
  pathEl.setAttribute('id', 'path');
  pathEl.setAttribute('fill', 'none');
  pathEl.setAttribute('stroke', 'black');
  pathEl.setAttribute('stroke-width', '2');
  sceneGroup.appendChild(pathEl);

  function updateSceneTransform() {
    sceneGroup.setAttribute('transform', `translate(${sceneTranslate.x},${sceneTranslate.y}) scale(${sceneScale})`);
  }

  const commandHandlers = {
    'M': s => s.pts.forEach(pt => createControlPoint(pt)),
    'L': s => s.pts.forEach(pt => createControlPoint(pt)),
    'Q': s => {
      createControlPoint(s.pts[0]);
      createControlPoint(s.pts[1], 'control');
      createControlPoint(s.pts[2]);
      createHelperLine(s.pts[0], s.pts[1]);
      createHelperLine(s.pts[1], s.pts[2]);
    },
    'C': s => {
      createControlPoint(s.pts[0]);
      createControlPoint(s.pts[1], 'control');
      createControlPoint(s.pts[2], 'control');
      createControlPoint(s.pts[3]);
      createHelperLine(s.pts[0], s.pts[1]);
      createHelperLine(s.pts[2], s.pts[3]);
    }
  };

  function redraw() {
    let d = '';
    clearControlPoints();

    segments.forEach(s => {
      if (commandHandlers[s.cmd]) {
        commandHandlers[s.cmd](s);
        switch (s.cmd) {
          case 'M':
            d += `M ${s.pts[0].x} ${s.pts[0].y} `;
            break;
          case 'L':
            d += `L ${s.pts[1].x} ${s.pts[1].y} `;
            break;
          case 'Q':
            d += `Q ${s.pts[1].x} ${s.pts[1].y}, ${s.pts[2].x} ${s.pts[2].y} `;
            break;
          case 'C':
            d += `C ${s.pts[1].x} ${s.pts[1].y}, ${s.pts[2].x} ${s.pts[2].y}, ${s.pts[3].x} ${s.pts[3].y} `;
            break;
        }
      }
    });

    pathEl.setAttribute('d', d.trim());

    logEl.textContent = segments.map(s => {
      switch (s.cmd) {
        case 'M':
          return `M ${s.pts[0].x.toFixed(1)} ${s.pts[0].y.toFixed(1)}`;
        case 'L':
          return `L ${s.pts[1].x.toFixed(1)} ${s.pts[1].y.toFixed(1)}`;
        case 'Q':
          return `Q ${s.pts[1].x.toFixed(1)} ${s.pts[1].y.toFixed(1)}, ${s.pts[2].x.toFixed(1)} ${s.pts[2].y.toFixed(1)}`;
        case 'C':
          return `C ${s.pts[1].x.toFixed(1)} ${s.pts[1].y.toFixed(1)}, ${s.pts[2].x.toFixed(1)} ${s.pts[2].y.toFixed(1)}, ${s.pts[3].x.toFixed(1)} ${s.pts[3].y.toFixed(1)}`;
      }
    }).join('\n');
  }

  function addPoint(x, y) {
    const rect = canvas.getBoundingClientRect();
    const screenToSvg = (x, y) => ({
      x: (x - rect.left - sceneTranslate.x) / sceneScale,
      y: (y - rect.top - sceneTranslate.y) / sceneScale
    });
    const pt = screenToSvg(x, y);

    const last = segments.length ? segments[segments.length - 1].pts.slice(-1)[0] : null;
    const createPts = {
      'M': () => [{ x: pt.x, y: pt.y }],
      'L': () => last ? [last, pt] : null,
      'Q': () => last ? [last, { x: (last.x + pt.x) / 2, y: (last.y + pt.y) / 2 - 50 }, pt] : null,
      'C': () => last ? [
        last,
        { x: last.x + (pt.x - last.x) * 0.3, y: last.y + (pt.y - last.y) * 0.3 - 30 },
        { x: last.x + (pt.x - last.x) * 0.7, y: last.y + (pt.y - last.y) * 0.7 + 30 },
        pt
      ] : null
    };
    const pts = createPts[currentMode]?.();
    if (!pts) return;
    segments.push({ cmd: currentMode, pts });
    redraw();
  }

  function createControlPoint(pt, type = '') {
    const circle = document.createElementNS(svgNS, "circle");
    circle.setAttribute('cx', pt.x);
    circle.setAttribute('cy', pt.y);
    circle.setAttribute('r', 5);
    circle.setAttribute('class', `control-point ${type}`);
    controlPointsGroup.appendChild(circle);

    let isDragging = false;
    let offsetX, offsetY;

    circle.addEventListener('mousedown', e => {
      e.preventDefault();
      isDragging = true;
      circle.classList.add('dragging');
      offsetX = e.clientX - pt.x * sceneScale - sceneTranslate.x;
      offsetY = e.clientY - pt.y * sceneScale - sceneTranslate.y;

      const move = e => {
        if (!isDragging) return;
        const x = (e.clientX - offsetX - sceneTranslate.x) / sceneScale;
        const y = (e.clientY - offsetY - sceneTranslate.y) / sceneScale;
        pt.x = x;
        pt.y = y;
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        redraw();
      };

      const up = () => {
        isDragging = false;
        circle.classList.remove('dragging');
        document.removeEventListener('mousemove', move);
        document.removeEventListener('mouseup', up);
      };

      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', up);
    });
  }

  function createHelperLine(pt1, pt2) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute('x1', pt1.x);
    line.setAttribute('y1', pt1.y);
    line.setAttribute('x2', pt2.x);
    line.setAttribute('y2', pt2.y);
    line.setAttribute('class', 'helper-line');
    helperLinesGroup.appendChild(line);
  }

  function clearControlPoints() {
    controlPointsGroup.innerHTML = '';
    helperLinesGroup.innerHTML = '';
  }

  canvas.addEventListener('mousedown', e => {
  if (e.button !== 0 || e.target.closest('.control-point')) return;

  isPanning = true;
  startPan = { x: e.clientX - sceneTranslate.x, y: e.clientY - sceneTranslate.y };
  canvas.style.cursor = 'grabbing';
});

canvas.addEventListener('mousemove', e => {
  if (isPanning) {
    sceneTranslate.x = e.clientX - startPan.x;
    sceneTranslate.y = e.clientY - startPan.y;
    updateSceneTransform();
  }
});

canvas.addEventListener('mouseup', () => {
  isPanning = false;
  canvas.style.cursor = isControllingBackground ? 'grab' : 'crosshair';
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–ª–µ—Å–∞ –º—ã—à–∏ (–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ)
canvas.addEventListener('wheel', e => {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;

  const beforeZoom = {
    x: (mouseX - sceneTranslate.x) / sceneScale,
    y: (mouseY - sceneTranslate.y) / sceneScale
  };

  sceneScale *= zoomFactor;
  sceneScale = Math.max(0.1, Math.min(sceneScale, 10));

  sceneTranslate.x = mouseX - beforeZoom.x * sceneScale;
  sceneTranslate.y = mouseY - beforeZoom.y * sceneScale;

  updateSceneTransform();
});

  canvas.addEventListener('click', e => {
    if (isControllingBackground || e.target.closest('.control-point')) return;
    addPoint(e.clientX, e.clientY);
  });

  toolsPanel.addEventListener('mousedown', e => {
    const header = document.getElementById('toolsHeader');
    if (header.contains(e.target)) {
      isDraggingPanel = true;
      panelOffsetX = e.clientX - toolsPanel.offsetLeft;
      panelOffsetY = e.clientY - toolsPanel.offsetTop;
    }
  });

  document.addEventListener('mouseup', () => isDraggingPanel = false);
  document.addEventListener('mousemove', e => {
    if (!isDraggingPanel) return;
    toolsPanel.style.left = (e.clientX - panelOffsetX) + 'px';
    toolsPanel.style.top = (e.clientY - panelOffsetY) + 'px';
  });

  window.togglePanel = function () {
    const isHidden = toolsPanel.classList.toggle('hidden');
    toggleBtn.classList.toggle('panelOpen', !isHidden);
    toggleBtn.textContent = isHidden ? '‚ò∞' : '√ó';
  };
  toggleBtn.onclick = togglePanel;

  undoButton.onclick = () => {
    segments.pop();
    redraw();
  };

  clearPathButton.onclick = () => {
    segments = [];
    redraw();
  };

  exportSvgButton.onclick = () => {
    const content = `<svg xmlns="${svgNS}" width="${canvas.clientWidth}" height="${canvas.clientHeight}">${canvas.innerHTML}</svg>`;
    const blob = new Blob([content], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'drawing.svg';
    a.click();
  };

  insertImageButton.onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = e => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = evt => {
        bgImage.setAttribute('href', evt.target.result);
        updateSceneTransform();
      };
      reader.readAsDataURL(file);
    };
    input.click();
  };

  toggleBgControlButton.onclick = () => {
    isControllingBackground = !isControllingBackground;
    toggleBgControlButton.classList.toggle('active', isControllingBackground);
    canvas.style.cursor = isControllingBackground ? 'grab' : 'crosshair';
  };

  modeButtons.forEach(button => {
    button.addEventListener('click', () => {
      currentMode = button.dataset.mode;
      modeButtons.forEach(b => b.classList.remove('active'));
      button.classList.add('active');
    });
  });

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  document.querySelector('[data-mode="M"]').classList.add('active');
  updateSceneTransform();
  addPoint(50, 50);
})();
</script>

</body>
</html>
