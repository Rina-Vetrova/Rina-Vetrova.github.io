<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif; 
      overflow: hidden;
      background: #f5f5f5;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: white;
      cursor: crosshair;
    }
    
    #toolsPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 250px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    #toolsPanel.hidden {
      transform: translateX(270px);
      opacity: 0;
    }
    
    #toolsHeader {
      padding: 15px;
      background: #333;
      color: white;
      border-radius: 10px 10px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #toolsContent {
      padding: 15px;
      max-height: 70vh;
      overflow-y: auto;
    }
    
    #toggleBtn {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: #333;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: all 0.3s ease;
    }
    
    #toggleBtn:hover {
      background: #555;
      transform: scale(1.1);
    }
    
    #toggleBtn.panelOpen {
      right: 290px;
    }
    
    button {
      width: 100%;
      margin: 5px 0;
      padding: 10px;
      border: none;
      border-radius: 5px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #0056b3;
    }
    
    button.active {
      background: #28a745;
    }
    
    textarea {
      width: 100%;
      height: 100px;
      margin: 5px 0;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }
    
    label {
      display: block;
      margin: 10px 0 5px 0;
      font-weight: bold;
      font-size: 14px;
    }
    
    hr {
      margin: 15px 0;
      border: none;
      border-top: 1px solid #eee;
    }
    
    #log {
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 11px;
      white-space: pre;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e9ecef;
    }
    
    .control-point {
      cursor: grab;
      transition: all 0.2s ease;
    }
    
    .control-point:hover {
      r: 7;
      fill: #dc3545;
    }
    
    .control-point:active {
      cursor: grabbing;
    }
    
    .helper-line {
      stroke: #999;
      stroke-width: 1;
      stroke-dasharray: 3,3;
      opacity: 0.6;
    }
    
    #modeSelector {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    #modeSelector button {
      flex: 1;
      font-size: 12px;
      padding: 8px 4px;
    }
  </style>
</head>
<body>

  <svg id="canvas" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#f0f0f0" stroke-width="1"/>
      </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#grid)" opacity="0.5"/>
    <image id="bgImage" x="0" y="0" width="0" height="0" href="" preserveAspectRatio="xMidYMid slice"/>
    <g id="helperLines"></g>
    <path id="path" fill="none" stroke="#333" stroke-width="3"/>
    <g id="controlPoints"></g>
  </svg>

  <button id="toggleBtn">‚ò∞</button>

  <div id="toolsPanel" class="hidden">
    <div id="toolsHeader">
      <span>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</span>
      <span style="cursor: pointer;" onclick="togglePanel()">√ó</span>
    </div>
    
    <div id="toolsContent">
      <div id="modeSelector">
        <button id="addMove" class="active">M</button>
        <button id="addH">H</button>
        <button id="addV">V</button>
        <button id="addLine">L</button>
        <button id="addQuad">Q</button>
        <button id="addCubic">C</button>
      </div>
      
      <button id="insertImage">üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ–Ω</button>
      <label for="imageScale">–ú–∞—Å—à—Ç–∞–± —Ñ–æ–Ω–∞:</label>
      <input type="range" id="imageScale" min="0.1" max="2" value="1" step="0.05">
      <button id="clearPath">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
      <button id="undo">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
      
      <hr>
            
      <label>SVG –∫–æ–¥:</label>
      <div id="log"></div>
    </div>
  </div>

<script>
(() => {
  const svg = document.getElementById('canvas');
  const pathEl = document.getElementById('path');
  const logEl = document.getElementById('log');
  const bgImage = document.getElementById('bgImage');
  const controlPointsGroup = document.getElementById('controlPoints');
  const helperLinesGroup = document.getElementById('helperLines');
  const toolsPanel = document.getElementById('toolsPanel');
  const toggleBtn = document.getElementById('toggleBtn');
  const imageScaleInput = document.getElementById('imageScale');

  let segments = [];
  let currentMode = 'M';
  let undoHistory = [];
  let imageScale = 1;

  // Draggable tools panel
  let isDraggingPanel = false;
  let panelOffsetX, panelOffsetY;

  toolsPanel.addEventListener('mousedown', (e) => {
    isDraggingPanel = true;
    panelOffsetX = e.clientX - toolsPanel.offsetLeft;
    panelOffsetY = e.clientY - toolsPanel.offsetTop;
    toolsPanel.style.cursor = 'grabbing';
  });

  document.addEventListener('mouseup', () => {
    isDraggingPanel = false;
    toolsPanel.style.cursor = 'move';
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDraggingPanel) return;
    toolsPanel.style.left = (e.clientX - panelOffsetX) + 'px';
    toolsPanel.style.top = (e.clientY - panelOffsetY) + 'px';
  });

  // Image scaling
  imageScaleInput.addEventListener('input', () => {
    imageScale = parseFloat(imageScaleInput.value);
    bgImage.setAttribute('transform', `scale(${imageScale})`);
  });

  // Toggle panel visibility
  window.togglePanel = function() {
    const isHidden = toolsPanel.classList.contains('hidden');
    if (isHidden) {
      toolsPanel.classList.remove('hidden');
      toggleBtn.classList.add('panelOpen');
      toggleBtn.textContent = '√ó';
    } else {
      toolsPanel.classList.add('hidden');
      toggleBtn.classList.remove('panelOpen');
      toggleBtn.textContent = '‚ò∞';
    }
  };

  toggleBtn.onclick = togglePanel;

  // Update canvas size
  function updateCanvasSize() {
    svg.setAttribute('width', window.innerWidth);
    svg.setAttribute('height', window.innerHeight);
  }

  updateCanvasSize();
  window.addEventListener('resize', updateCanvasSize);

  function createControlPoint(pt, className = '') {
    const circle = document.createElementNS(svg.namespaceURI, 'circle');
    circle.setAttribute('cx', pt.x);
    circle.setAttribute('cy', pt.y);
    circle.setAttribute('r', 5);
    circle.setAttribute('class', 'control-point ' + className);
    controlPointsGroup.appendChild(circle);
    
    let isDragging = false;
    let startX, startY;
    
    circle.addEventListener('mousedown', e => {
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      circle.classList.add('dragging');
      startX = e.clientX - pt.x;
      startY = e.clientY - pt.y;
      
      const onMouseMove = e => {
        if (!isDragging) return;
        pt.x = e.clientX - startX;
        pt.y = e.clientY - startY;
        circle.setAttribute('cx', pt.x
);
        circle.setAttribute('cy', pt.y);
        redraw();
      };
      
      const onMouseUp = () => {
        isDragging = false;
        circle.classList.remove('dragging');
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
    
    return circle;
  }

  function createHelperLine(pt1, pt2) {
    const line = document.createElementNS(svg.namespaceURI, 'line');
    line.setAttribute('x1', pt1.x);
    line.setAttribute('y1', pt1.y);
    line.setAttribute('x2', pt2.x);
    line.setAttribute('y2', pt2.y);
    line.setAttribute('class', 'helper-line');
    helperLinesGroup.appendChild(line);
    return line;
  }

  function clearControlPoints() {
    controlPointsGroup.innerHTML = '';
    helperLinesGroup.innerHTML = '';
  }

  const commandHandlers = {
    'M': (ctx, s) => s.pts.forEach(pt => { ctx.moveTo(pt.x, pt.y); createControlPoint(pt); }),
    'L': (ctx, s) => { ctx.lineTo(s.pts[1].x, s.pts[1].y); createControlPoint(s.pts[0]); createControlPoint(s.pts[1]); },
    'H': (ctx, s) => { ctx.lineTo(s.pts[1].x, s.pts[0].y); createControlPoint(s.pts[0]); createControlPoint(s.pts[1]); },
    'V': (ctx, s) => { ctx.lineTo(s.pts[0].x, s.pts[1].y); createControlPoint(s.pts[0]); createControlPoint(s.pts[1]); },
    'Q': (ctx, s) => {
      ctx.quadraticCurveTo(s.pts[1].x, s.pts[1].y, s.pts[2].x, s.pts[2].y);
      createControlPoint(s.pts[0]);
      createControlPoint(s.pts[1], 'control');
      createControlPoint(s.pts[2]);
      createHelperLine(s.pts[0], s.pts[1]);
      createHelperLine(s.pts[1], s.pts[2]);
    },
    'C': (ctx, s) => {
      ctx.bezierCurveTo(s.pts[1].x, s.pts[1].y, s.pts[2].x, s.pts[2].y, s.pts[3].x, s.pts[3].y);
      createControlPoint(s.pts[0]);
      createControlPoint(s.pts[1], 'control');
      createControlPoint(s.pts[2], 'control');
      createControlPoint(s.pts[3]);
      createHelperLine(s.pts[0], s.pts[1]);
      createHelperLine(s.pts[2], s.pts[3]);
    }
  };

  function redraw() {
    let d = '';
    clearControlPoints();

    segments.forEach(s => {
      const handler = commandHandlers[s.cmd];
      if (handler) {
        //handler(svg, s); // svg doesnt have those methods, it needs to be a canvas context
        d += s.cmd + ' ' + s.pts.map(pt => `${pt.x} ${pt.y}`).join(' '); // —É–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ d
      } else {
        console.warn('Unknown command:', s.cmd);
      }
    });

    pathEl.setAttribute('d', d.trim());

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
    logEl.textContent = segments.map(s => `${s.cmd} ${s.pts.map(pt => `${pt.x.toFixed(1)} ${pt.y.toFixed(1)}`).join(' ')}`).join('\n');
  }

  function addPoint(x, y) {
    const last = segments.length ? segments[segments.length-1].pts.slice(-1)[0] : null;
    let pts = [];
    
    const createPts = {
      'M': () => [{x, y}],
      'H': () => last ? [{x: last.x, y: last.y}, {x, y: last.y}] : null,
      'V': () => last ? [{x: last.x, y: last.y}, {x: last.x, y}] : null,
      'L': () => last ? [{x: last.x, y: last.y}, {x, y}] : null,
      'Q': () => last ? [
        {x: last.x, y: last.y},
        {x: (last.x + x) / 2, y: (last.y + y) / 2 - 50},
        {x, y}
      ] : null,
      'C': () => last ? [
        {x: last.x, y: last.y},
        {x: last.x + (x - last.x) * 0.3, y: last.y + (y - last.y) * 0.3 - 30},
        {x: last.x + (x - last.x) * 0.7, y: last.y + (y - last.y) * 0.7 + 30},
        {x, y}
      ] : null
    };
  
    const ptsCreator = createPts[currentMode];
    pts = ptsCreator ? ptsCreator() : null;
    
    if (pts) {
      const newSegment = {cmd: currentMode, pts: pts};
      undoHistory.push(segments.slice()); // Save current state
      segments.push(newSegment);
      redraw();
    }
  }

  // Undo functionality
  document.getElementById('undo').addEventListener('click', () => {
    if (undoHistory.length > 0) {
      segments = undoHistory.pop(); // Restore previous state
      redraw();
    }
  });

  // Event listeners for tool buttons
  document.getElementById('addMove').addEventListener('click', () => {currentMode = 'M'; updateModeButtons();});
  document.getElementById('addH').addEventListener('click', () => {currentMode = 'H'; updateModeButtons();});
  document.getElementById('addV').addEventListener('click', () => {currentMode = 'V'; updateModeButtons();});
  document.getElementById('addLine').addEventListener('click', () => {currentMode = 'L'; updateModeButtons();});
  document.getElementById('addQuad').addEventListener('click', () => {currentMode = 'Q'; updateModeButtons();});
  document.getElementById('addCubic').addEventListener('click', () => {currentMode = 'C'; updateModeButtons();});

  function updateModeButtons() {
    document.querySelectorAll('#modeSelector button').forEach(button => {
      button.classList.remove('active');
    });
    document.getElementById('add' + currentMode).classList.add('active');
  }

  // Load background image
  document.getElementById('insertImage').addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        bgImage.setAttribute('href', e.target.result);
        const img = new Image();
        img.onload = () => {
          bgImage.setAttribute('width', img.width);
          bgImage.setAttribute('height', img.height);
          bgImage.setAttribute('transform', `scale(${imageScale})`); // Apply initial scale
        }
        img.src = e.target.result;
      }
      reader.readAsDataURL(file);
    };
    input.click();
  });

  // Clear path
  document.getElementById('clearPath').addEventListener('click', () => {
    undoHistory.push(segments.slice()); // Save current state before clearing
    segments = [];
    redraw();
  });

  // Click on SVG
  svg.addEventListener('click', e => {
    const x = e.offsetX;
    const y = e.offsetY;
    addPoint(x, y);
  });

  // Initialization
  updateModeButtons();
  redraw();
})();
</script>
</body>
</html>
